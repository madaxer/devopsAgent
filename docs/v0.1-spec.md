# DevOps AI Framework v0.1 Spec

## Goal

Provide a safe AI-assisted operations workflow where a local client can ask for operational tasks and a remote agent on GCP executes approved actions with auditability.

## Scope

Included in v0.1:
- Client CLI with natural language command entry.
- Agent app deployed to one GCP VM.
- Typed action API (no arbitrary shell endpoint in v0.1).
- Read operations: Docker logs, Kubernetes pod logs/events, JVM status/thread dump.
- Write operations: restart service/container, scale Kubernetes deployment.
- Basic policy checks, confirmation gates, and audit logging.

Not included in v0.1:
- Full web UI.
- Multi-tenant org model.
- Autonomous remediation loops.
- Broad cloud provider support beyond initial GCP host.

## High-Level Architecture

Components:
- `client`: local CLI orchestrator + AI planner.
- `agentapp`: remote API service running on GCP VM.
- `connectors`: action executors for Docker, Kubernetes, JVM, system services.
- `policy`: allowlist + RBAC + confirmation rules.
- `audit`: append-only action/event records.

Flow:
1. User sends natural language request in CLI.
2. AI planner converts request to typed action request(s).
3. Client asks for confirmation when policy marks action as risky.
4. Client signs request and sends it to agentapp.
5. Agent validates auth, policy, and action schema.
6. Agent executes through connector and streams progress/logs.
7. Agent records full audit event and returns result.

## Trust and Security Model

Authentication and authorization:
- Client obtains short-lived token (JWT) from identity provider.
- Agent validates token signature and claims (`sub`, `role`, `env`).
- Agent enforces RBAC + allowlist per environment.

Transport and secrets:
- TLS mandatory.
- Prefer mTLS for client-agent traffic in private network.
- Store secrets in GCP Secret Manager.

Safety controls:
- Default deny for unknown actions.
- Explicit action allowlist by environment.
- Confirmation required for mutating actions in `stage` and `prod`.
- Per-action timeout and output size limits.

## Canonical Action Model

```json
{
  "request_id": "uuid",
  "requested_at": "2026-02-15T10:00:00Z",
  "requested_by": "engineer@company.com",
  "environment": "staging",
  "action": "k8s.scale_deployment",
  "target": {
    "cluster": "gke-staging",
    "namespace": "payments",
    "name": "payment-api"
  },
  "params": {
    "replicas": 5
  },
  "require_confirmation": true
}
```

Result model:

```json
{
  "request_id": "uuid",
  "status": "succeeded",
  "started_at": "2026-02-15T10:00:02Z",
  "finished_at": "2026-02-15T10:00:08Z",
  "summary": "Scaled payments/payment-api from 3 to 5",
  "artifacts": [
    {
      "type": "k8s_event",
      "value": "Scaled replica set payment-api-7d8c to 5"
    }
  ]
}
```

## Action Catalog (v0.1)

Read actions:
- `docker.logs` params: `container`, `since`, `tail`, `follow`.
- `k8s.pod_logs` params: `cluster`, `namespace`, `pod`, `container`, `since`, `tail`, `follow`.
- `k8s.events` params: `cluster`, `namespace`, `kind`, `name`, `since`.
- `jvm.status` params: `host`, `pid` or `service`.
- `jvm.thread_dump` params: `host`, `pid` or `service`.
- `vm.list_path` params: `path`.
- `vm.find_path` params: `base_path`, `name_pattern`.
- `vm.read_file` params: `path`, optional `offset`, optional `limit`.

Write actions:
- `docker.restart_container` params: `container`.
- `service.restart` params: `service_name`.
- `k8s.scale_deployment` params: `cluster`, `namespace`, `name`, `replicas`.

Policy defaults:
- Read actions: no confirmation in `dev`/`stage`, optional in `prod`.
- Write actions: confirmation required in `stage`/`prod`, optional in `dev`.

## Agent API (v0.1)

Endpoints:
- `POST /v1/actions/plan` optional server-side validation and policy preview.
- `POST /v1/actions/execute` execute one action request.
- `GET /v1/actions/{request_id}` fetch execution status/result.
- `GET /v1/actions/{request_id}/stream` stream live output (SSE).
- `GET /v1/health` service health and connector readiness.

Execution states:
- `received`
- `validated`
- `awaiting_confirmation`
- `running`
- `succeeded`
- `failed`
- `denied`
- `timed_out`

## Client CLI Commands (v0.1)

- `devops-ai ask "<natural language request>"`
- `devops-ai run --action <action> --target <json> --params <json>`
- `devops-ai status <request_id>`
- `devops-ai stream <request_id>`
- `devops-ai policy check --action <action> --env <env>`

Behavior:
- AI mode: parse intent, generate one or more typed actions, show plan, ask confirmation if needed.
- Direct mode: execute explicit typed actions without planner.

## Data and Audit

Minimum audit fields:
- `request_id`, `actor`, `environment`, `action`, `target`, `params_hash`.
- `decision` (`allowed`, `denied`, `confirmed`).
- `status`, `duration_ms`, `error_code`, `output_hash`.

Storage:
- v0.1 can use SQLite or Postgres on agent VM.
- Logs/output blobs can be retained locally with TTL.

## Non-Functional Requirements

- p95 read action response start < 2s.
- Streaming latency < 1s for follow/log actions.
- Action execution timeout defaults to 60s (override per action).
- All writes are idempotency-key protected (`request_id`).

## Verification Criteria

v0.1 is successful when:
- Client can request logs from Docker and Kubernetes through typed actions.
- Client can restart service/container and scale deployment with confirmation gates.
- Every action creates an audit record with actor, decision, and result.
- Denied actions are blocked and logged with decision metadata.
- End-to-end demo works against one GCP VM and one GKE cluster.
